<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>정호의 연습노트</title>
        <link rel="stylesheet" href="style.css">
</head><!-- 3단 레이아웃 구조로 만들기 -->

<body>
    <div class="로회">
        <a href="로그인.html" class="로그인">로그인</a><a href="회원가입1.html">회원가입</a>
    </div>

    <header class="banner">
        <h1><a href="index.html">정호의 연습노트</a></h1>
    </header>

    <div class="grid">
        <aside class="leftbar">
            <details open>
                <summary>공부중인 것!</summary>
                <ul>
                    <li><a href="1.html">HTML/CSS</a></li>
                    <li><a href="2.html">자바스크립트</a></li>
                    <li>미정</li>
                    <li>미정</li>
                    <li>미정</li>
                    <li>미정</li>
                </ul>
            </details>

            <details open>
                <summary>도움을 준 친구들</summary>
                <ul>
                    <li><a href="3.html">chat GPT</a></li>
                    <li><a href="미완.html">유튜브</a></li>
                    <li><a href="미완.html">타자연습</a></li>
                    <li>미정</li>
                    <li>미정</li>
                    <li>미정</li>
                </ul>
            </details>

            <details>
                <summary>발자취</summary>
                <ul>
                    <li><a href="미완.html">생각의 타임라인</a></li>
                    <li><a href="미완.html">끄적끄적</a></li>
                    <li>미정</li>
                </ul>
            </details>
        </aside>


        <main class="content">
            <h2>HTML/CSS</h2> <a href="용어정리.html"> html & css 태그 속성 정리</a><!-- 메인의 게시글 눌렀을때 아래로 간략하게 설명이 펼쳐지는 형식-->
            <ol>
                <details>
                    <summary>HTML 기본적인 구조</summary>
                    <p>html은 말그대로 맨땅에서부터 기초를 다지는 작업. 어디서부터 어디까지를 마당으로 쓸건지,
                        어디가 집안 부지이고 그 안에서도 투룸인지 원룸인지를 판가름하는 설계도이자 각종 태그와 속성을 섞어가며 쌓아가는 최전선의 직조물.
                    <p>HTML의 기본적인 구조는 아래와 같은 뼈대에서 시작.
                    <pre>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        (meta는 인코딩방식을 나타내며 헤드의 제일 위에 위치 해야함. 그래야 글자가 깨지지 않음.)

        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    
         (모바일 화면에서 볼때, 웹상에서 의도한대로의 화면배치를 볼 수 있게 해줌.)

         &lt;title&gt; (웹브라우저 탭의 이름)  &lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;                   &lt;!--웹 브라우저의 뼈대가 들어가는 위치 바디.--&gt;

    &lt;/body&gt;
&lt;/html&gt;
                            </pre>
                    </p>
                </details>

                <details>
                    <summary>CSS 기본적인 구조</summary>
                    <p> html은 뭐랄까 대들보? 골조? 골격과 같은 레이아웃이나 큰 틀을 닦는 기반이라면, CSS는 그런한 골조를 장식하는 데코레이션.
                        <br>최초 html을 통해서 최소한의 운영이 이루어지다가 금세 심미적인 부분에서 욕심이 나기 시작했고 더 효율적이고 직관적인 수식을 하기위해 만들어짐.
                        왜 html, css를 나누어서 관리를 하는가를 생각해보면 html을 통해서 우리는 구조설계와 보수를 지속적으로 해나간다. 그때 중간중간 구조적 기능이 아닌 심미적
                        인테리어의 언어들이 섞여있다면 훗날 어딘가에서 구조적인 문제를 발견했을때 직관적으로 알아보기 힘들고 시간을 더 소모해야 할 가능성이 생긴다.
                    <p> 그에따라 일반적으로 &lt;body&gt; 태그 안쪽에는 html을 갖추고, &lt;head&gt;안쪽으로
                        &lt;style&gt;를 넣어서 css를 직접 모아둘 공간을 마련해둔다. 한번에 관리를 하기때문에 직관적으로 확인하기 쉬우며 종종 태그 자체에 스타일 속성으로 직접 변화를
                        주긴하지만,
                        후에 개보수의 편의성을 위해서 직접설정은 지양하는 분위기다. 23:03 2025-05-23</p>

                </details>

                <details>
                    <summary>head, body, header, main / div 태그의 차이</summary>
                    <p>head 와 body는 가장가장 큰 분류단위라고 생각됨. 실직적인 부분, 즉 공간적 부지 설정 및 내용물은 body에서 이뤄진다면, head는 좀더 추상적인 "지금부터 이집은
                        어떤 목적의 건축물이다.
                        상가다 혹은 거주지다!" 등과 같은 선언과 어떻게 이 문서를 바라봐 줘야 할지에 대한 설명서적인 구조를 당담하는 부분.</p>
                    <p> 또한 head 섹션에 style을 넣어서 css를 일목요연하게 확인하고
                        수정을 할 수 있는 공간이 되어주며, 페이지마다 같은 css를 공유하는 경우에는 style.css의 파일로 따로 추출하여 파일 자체를 링크하는식으로 간략화하기도 한다.
                        이때 링크 하는 방법은, &lt;link rel="stylesheet" href="style.css"&gt;</p>
                    <p>header, main 태그는 body안에서 이뤄지는 한번더 나눠지는 대략적으로 머릿말 부분이다 혹은 이쪽을 메인, 사이드바로 쓰겠다.와 같은 공간적선언으로 생각하면 되겠으며
                        코드만 보고 구조를 이해할때 용의하다.</p>
                    <p>div 태그는 임의에 그룹단위로 묶기위해 사용되어지며 css를 통해 같은 그룹내의 태그들을 한번에 수식 할 수 있다. 통상 class 와 id가 같이 사용 되며 임의로 묶인
                        그룹에 이름을 붙여주는 속성이다.
                        <br>ex) div class="main"
                    </p>

                </details>

                <details>
                    <summary>div, span과 class, id 태그의 상관관계와 속성 적용 우선순위</summary>
                    <h3>div와 class, id 태그의 상관관계와 속성 적용 우선순위</h3>
                    <p>위 설명에서 언급했지만 class와 id는 포장한 박스에 이름을 붙여주는 행위. 어떤 그룹을 전체적으로 수식해주고 꾸며주기위해 div로 묶어주며 그 묶음의 이름을 붙여줌.
                        <br>이 때 class는 기본적인 그룹이라면, id는 격이 높은 지정으로 겹구조로 수식이 될 때 id로 지정한것이 더 우선순위이다. 마찬가지로 같은 class끼리의
                        수식일때는 마지막으로 쓰인것이 적용되지만,
                        <br>가령 .class 와 .class pre 같은 경우 좀더 세분화해서 수식한 .class pre 가 우선순위로 받아 드려진다.
                    </p>

                    <p>div와 같은선상으로 쓰이는 span의 경우는 결이 조금 다른데 div가 포괄한 태그들 혹은 text는 박스화해서 노출되지만, span같은 경우는 인라인 상태에서 수식을
                        해줌.
                        <br>이뜻을 쉽게말하면 배너나 목차처럼 박스화된 피수식구조들은 div를 쓰겠지만, 일반적인 text를 사용 하던 중 특정 문장 혹은 단어를 묶음지을때는 span을
                        사용하는것이 간편하다.
                        <br>그 이유는 div경우는 기본설정 display가 박스형이라면 span은 인라인으로서 줄바꿈이 일어나지 않고 그상태에 문장에서 묶음지을 수 있기때문이다.
                        <br>물론 서로 디스플레이 속성값을 강제로 바꿈으로서 어디에든 사용 할 순 있겠지만 그렇게 늘어나는 코드는 좋지 못한 습관이라는 시각. 구지??

                        <br>.span { display: block; } or .span { display: inline-block; }를 통해 박스화 시키면 그에따라 너비와 높이조정도
                        가능해짐.
                        <br>디스플레이 종류는 블록 /인라인 /인라인-블록
                        <br>22:02 2025-05-25
                    </p>
                </details>

                <details>
                    <summary>details과 summary 태그의 기능 </summary>
                    <h2>details과 summary 태그의 기능</h2>

                    <p>html자체적으로 펼치기?? 기능을 할 수 있는 details태그, 그 소제목이 되어줄 summary, 안쪽에는 텍스트를 채워넣어, 눌렀을때 자연스럽게 펼쳐지면서 내용을 펼칠
                        수 있다.
                        사이드 네비게이션 바를 운용할 때 좋을것 같으며 여러곳에 응용하여 쓰기 좋을듯 하다.</p>

                    <p>기본 화살표 <del>디스플레이를</del> 리스트-스타일을 none하여 없애고 원하는 손가락이나 사물, 이미지등을 삽입하여 돌아가게 하여 자연스럽게 만들 수 있다.
                        이때 우리는 기존의 서머리의 리스트-스타일을 없애주고 우리가 원하는 것을 삽입하여 직접 그것을 90도 돌림으로서 대체하는것처럼 보이게하는것.</p>

                    <pre>details summary {
                        list-style: none;
                    }
                    
                    을 통하여 화살표를 없애주고, 새로넣은 아이콘을 span으로 인라인블럭 지정. 그 후 애니메이션 속도를 자연스럽게 하기위한 transition: transform 0.3s ease; 추가
                    
                    summary
                       span ▶ /span


                    span {
                       display: inline-block;
                       transition: transform 0.3s ease;
                    }
                    속도 설정까지 하였다면
                    
                    details[open] span {
                       transform: rotate(90deg);
                    }
                    디스플레이가 열린상태일때 우리가 넣은 아이콘이 90도 돌아가도록 설정추가.
                    23:56 2025-05-25
                    
-----------------------------------------------------------------------------------------------------------------------
            
                    추가적으로 ::before 이라는 가상요소를 공부하면서 새로운 방법 추가.

                    summary {
                      position: relative;
                    }

                    details summary::before {
                       display: inline-block
                       content:"▶";
                       position: absolute;
                       transition: transform 0.3s ease;
                       left: 0px
                    }
                    으로 서머리 앞에 ▶를 추가 하고

                    details[open] summary::before {
                       transform: rotate(90deg);
                    }
                    트렌스폼을 통해 90도 회전방식으로 같은 일을 할 수 있음.
                    요약하자면, 
                    1번 방법은 ▶를 직접 서머리 내용으로 넣고(html으로 ▶을 입력) css로 ▶만 회전.
                    2번 방법은 서머리의 비포에 css로 ▶을 생성하여 그것을 회전.   

                    결과적으로 1번 방법이 이미지의 크기나 여러가지를 조절하는데 용이 범용적임. 
                    1번으로 우측 화살표를 할땐 플렉스 구조를 활용하고 justify-content: space-between; 통해 우측정렬

                    00:52 2025-05-28
                </pre>
                </details>

                <details>
                    <summary>레이아웃 정리용 태그 모음</summary>
                    <p style="text-indent: 0;">
                        header 머릿말
                        <br>footer 바닥글 레이아웃상 바닥글 혹은 메인의 바닥부분으로 사용 저작권 및 참고 자료 등등
                        <br>main 본문
                        <br>nav 좌측 사이드 바, 네비게이션 바
                        <br>article ?? 독립적 완전체??
                        <br>section 문서내 특정 그룹끼리 나누는.. ex 넷플릭스나 애니 사이트메인 같은...
                        <br>01:14 2025-05-25
                    </p>
                </details>

                <details>
                    <summary>form 콘트롤을 위한 태그와 속성 모음</summary>
                    <pre><p>
&lt;input&gt;		 	기본형 +type 으로서 작동을 시킬 수 있다. 기본형은 text  
	type="text"  		글을 넣을 수 있는 바. 넣기전 설명은  placeholder="회색으로 설명(가이드문구)". 이미 값이 입력된상태로 로딩은 value=""  
	type="password"	 	text와 같은 형식이지만 비밀번호처리 해주는 바  
	type="radio"		동그란 체크칸. name으로 투표군을 묶을 수 있고, value를 통해 체크된 값의 의미가 뭔지 설정함.  checked를 통해 미리 체크가능.  
	type="checkbox"	 	네모난 체크칸 다중선택 가능. 속성값은 라디오와 같음.  
	type="file"  		파일을 업로드 하는 태그 솔직히 아직 정확히 어떻게 쓰는지 모르겠음.  
	type="button"		텍스트를 버튼화 시킴. 인풋 타입버튼은 구시대적 사용법 이라고 배움.  
	type="submit"		서버로 전송의 역할  
		required 속성	 해당 input을 채워야만 폼 제출이 가능.  
-------------------------------------------------------------------------------------------------------------
&lt;select&gt;			많은 리스트 중(ex. 국적, 생년월일 등) 선택할 때 사용.  
&lt;option&gt;			셀렉의 자식태그. 리스트를 구성하며 value를 통해 의미부여 필요. selected 속성을 통해 로딩시 최초 선택목록 설정가능. ex) &lt;option value="kr" selected&gt;한국&lt;/option&gt;

&lt;label&gt;			인풋의 체크박스나 라디오의 벨류값을 시각화하는 text를 그 상호작용칸과 묶어주는, 사용감을 올려주기위해 쓰는 태그? 인풋과 텍스트를 앞뒤로 감쌈  
	    for="id" 		for속성을 통해서 라벨과 텍스트를 물리적으로 감싸지 않고도 id값을 직접지정으로 수식해줄 수 있음.  

&lt;textarea&gt;		placeholder="회색으로 설명(가이드문구)"가 가능하고 태그사이에 텍스트를 써놓는 것으로 로딩시 출력이 가능 ex) &lt;textarea&gt;이렇게&lt;/textarea&gt; (input type="text"의 value와 같음)

&lt;button&gt;	    	타입버튼보다 더 다양하게 사용할 수 있음. 타입은 (폼태그 내에서)버튼, 서밋, 리셋 타입 사용가능. 폼내에서 서밋 사용시 작성된내용 제출, 리셋은 폼콘트롤 입력값 초기화.

&lt;form&gt;			사이트에 인풋류의 정보를 넘기는 태그?
-------------------------------------------------------------------------------------------------------------
a태그 	    href 사용하여 파일을 불러올때 절대경로와 상대경로에 대해서 알아야한다.  
           절대경로는 /로 시작하여 최초 상위태그에서 부터 찾아들어온다. 상대경로는 지금파일의 위치기준으로 시작하여 ./파일명 or ../파일명 의 모양. 앞에붙은 .하나당 상위폴더로 올라가서 파일명을 찾아 불러온다.  

img        src=""을 통해 링크 혹은 파일명으로 이미지를 불러옴.  width, height로 이미지의 크기 조정.

table 	   표를 만들어서 보여줘야 할때 사용.  자체적으로 thead를 사용함으로 구조상 구분을지어 사용하는걸 지향한다.  
	thead                              tbody  
	   tr                                   tr  
	    th 1행 1열 /th	                      td 2행 1열 /td  
	    th 1행 2열 /th	                      td 2행 2열 /td  
	   /tr                                  tr  
	/thead                             /tbody  

01:14 2025-05-25</p>
                    </pre>
                </details>

                <details>
                    <summary>부자관계와 형제 관계</summary>
                    <h2><strong>부자관계와 형제 관계</strong></h2>
                    <p>형제관계는 형:조건 + 동생 {형이 조건 했을때 동생이 {}한다.}
                        <br>ex) input[type="checkbox"]:checked +label 혹은 input[type="checkbox"]:not(:checked) + label
                        <br>(+동생1+동생2와 같이 여러개의 동생이 붙었을때는 제일 마지막 동생2만 수식이 된다.)
                        <br>형제관계에서 ~를 썼을때는 뒤에오는 태그들중 같은태그를 전부 수식한다. ~p경우 &lt;p&gt; &lt;br&gt; &lt;p&gt; 이중 p만을 수식, ~*는
                        모든태그 수식
                        <br>부자관계는 부모:has(자식태그:조건){자식이 조건 했을때 부모가 {}한다.} ex) label:has(input:checked)
                    </p>

                    <p>인풋과 라벨을 통해 형제, 부자관계를 자세히 배움.
                        형제는 인풋이 먼저등장 후 다음에 나오는 라벨이 for속성을 통해 인풋의 id를 직접 지정하는구조.
                        <br>부자는 인풋과 텍스트를 라벨로 감쌌을때 라벨은 부모, 인풋은 자식구조가 됨.
                        <br><del> has를 형제구조에도 사용 하는 방법으로는 형제를 div로 묶음하여 div와 2자식구조로 변환 후 div:has(input:조건)으로 사용하는방법.
                        </del> 라고 생각했으나
                        <br>이렇게 할 경우 인풋이 체크가 되었을때 라벨이 변화하는것이 아닌, 묶음 박스가 변화하는구조 따라서 옳지 못한 사용
                        <br>따라서 관계에 따른 적절한 태그를 사용하는것이 직관적이고, 수정하기 쉬운 코드를 짤 수 있음.00:24 2025-05-25
                    </p>
                </details>

                <details>
                    <summary>플렉스 구조와 그리드 구조.</summary>
                    <h2>플렉스 구조와 그리드 구조.</h2>

<pre>웹사이트라는 도화지를 기준으로 원하는 비율 혹은 픽셀값으로 구역을 나누게 되는데 그렇게 나눠진 구역에 맞춰 내가 입력한 결과물이 낑겨들어가면 그리드.
플렉스는 조금더 단순하게 원하는 비율 혹은 픽셀값으로 입력할 결과물이 늘어나고 작아진 상태로 웹에 나타나는것이 플렉스.
그리드는 세부적인 공간설정으로 세세한 위치를 잡는다면, 플렉스는 단순이 펼치고 쌓고의 작업을 직관적으로 할 수 있음. 따라서 섞어서 사용했을때 좋다고 생각함.


	      배너
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                                이러한 레이아웃 구조에선 상단 배너와
어ㅣ      메      ㅣ 광
사ㅣ               ㅣ            ← 메인 그리드         중간 그리드 구조           grid-template-areas: "leftbar content rightbar"( 먼저 각 클래스 에어리어 설정 선행)
이ㅣ      인      ㅣ 고
드ㅣ               ㅣ                                       푸터를 플렉스로 세로정렬.  display: flex; , flex-direction: column;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ                                 
           푸터                                             

02:01 2025-05-28


플렉스 부모 사용 속성
flex-direction(정렬축 결정) : row(가로정렬: 기본값), column(세로정렬)
flex-wrap(줄바꿈) : nowrap(줄바꿈 없음 오버플로우: 기본값), wrap(너비 넘어갈시 자동 줄바꿈 허용)
flex-flow(통합버전): direction, wrap

justify-content(주축 정렬) : flex-start, flex-end, center, space-between, space-around, space-evenly
align-items(교차축 정렬): flex-start, flex-end, center, baseline, stretch(기본값)
align-content(여러줄 교차축 정렬): flex-start, flex-end, center, space-between, space-around, stretch(기본값)

플렉스 자식 속성
flex-grow: 0 초기값. 여분 공간을 비율대로 분배
flex-shrink: 1 초기값. 부족시 줄어드는 비율
flex-basis: 길이px 크기설정 그로우와 슈린크의 연산기준값. auto설정시 height와 width의 값으로 됨. 연산은 적용
flex: grow shrink basis;
align-self: auto, flex-start, flex-end, center, baseline, stretch
order: 아이템의 순서 재배열. 주로 모바일 및 특정환경에서 구조순서를 바꿀때 사용.


그리드 부모 속성
grid-template-columns(열 너비): 200px 1fr 200px
grid-template-rows(행 너비): auto 100px	
grid-template-areas(영역설정): "nav main aside"
grid-template (행 열 통합설정): rows / columns

grid-auto-columns(열 자동생성시 크기): 100px
grid-auto-rows(행 자동생성시 크기): 100px
grid-auto-flow(자동생성 방향): rows(기본값), column, dense(빈공간시 사이로 들어감)
gap/ row-gap, column-gap (행열 간격설정): 20px

justify-content: start, center, end, space-between
align-content: star, center, end, stretch
justify-item: star, center, end, stretch
align-item: star, center, end, stretch

그리드 자식 속성
grid-column(열 지정):1/3(1번선에서 3번선까지 2칸먹기) , span2(2칸먹기) 
grid-row(행 지정):1/3(1번선에서 3번선까지 2칸먹기) , span2(2칸먹기)
grid-area(이름설정/ 좌표설정): row-start, col-start, row-end, col-end/ 이름설정 
justify-self: star, center, end, stretch
ailgn-self: star, center, end, stretch
place-self(통합형): align, justify

00:23 2025-06-03


                    </pre>
                </details>

                <details>
                    <summary>가상요소 ::before  ::after</summary>
                    <h2>가상요소 ::before  ::after</h2>
                        <pre>
                        footer의 컨텐츠를 만들면서 링크간 중앙선을 생성하고 싶었음. footer span:not(:last-child)::before {} 을 통해서 중앙선을 만들면서 가상요소::에 대해서 배움.
                        ( )는 조건, [ ]는 속성...
                        footer					
                        display: flex		← 혹은 span 자체를 인라인 블럭으로 펼쳐도 됨.
                        
                        footer span
                        position: relative;		← 비폴로 생성할때 기준점 설정
                        
                        
                        footer span:not(:last-child)::before {              ← '마지막 자녀가 아닌' 푸터내의 스펜 비포 위치에 {}를 한다.
                        content: "";                      ← 가상의 선을 생성
                        
                        width: 2px;                            ←
                        top: 25%;				가로2px이며 탑과 바텀의 25%지점부터 생성되는 검은색
                        bottom:25%;		           생성되는 선의 세부사항
                        background-color: #000;	      ←
                        }

                        left: 0px;			      ← 생성되는 선의 위치
                        position: absolute;		  ←
                        
                        방법과 더불어 더 간편한
                        
                        footer span:not(:first-child){
                           border-left: 2px solid #ccc    ← 볼더를 통한 간편한 선 생성. 단 선의 정밀한 위치와 길이 컨트롤 힘듬.
                        }
                        01:49 2025-05-28
                        
                        </pre>

                </details>

                <details>
                    <summary>트랜지션과 애니메이션 차이</summary>
                    <p>
트랜지션은 기본적으로 어떠한 트리거 즉 조건으로 시작. 가령 호버나 액션, 포커스일때 어떤 변화값을 조절하는 속성이라면,

<br>애니메이션의 경우 설계자의 의도에따라 지연시작, 바로시작, 등 트리거 없이 움직이는 값을 설정한대로 실행시킬 수 있음. 
+@keyframes 을 연동하여 정확한 좌표값으로 세세한 설정이 가능 

<br>@keyframes 이름 : 키프레임의 이름 설정과 애니메이션의 모양 위치 스타일등의 시각적인 설정을 하는곳
<br>animation: 어떻게 움직일 것인지?를 세세히 설정하는것 가령, 지속시간 반복횟수 방향 가속도 등등..
-name: 사용할 키프레임 네임 타깃
<br>19:11 2025-06-03</p>
                </details>

                <details>
                    <summary>-</summary>
                    <p>내용</p>
                </details>

                <details>
                    <summary>-</summary>
                    <p>내용</p>
                </details>

            </ol>
        </main>

        <aside class="rightbar">
            광고도 받을만한 사이트를 만들겠다는 당찬 포부
        </aside>
    </div>
    <footer>
        <span class="ggg">AAA</span><span class="ggg">BBB</span><span class="ggg">CCC</span>
        <span class="ggg">DDD</span><span class="ggg">EEE</span><span class="ggg">FFF</span>
        <span class="GGGG">GGG</span>
    </footer>

</body>

</html>